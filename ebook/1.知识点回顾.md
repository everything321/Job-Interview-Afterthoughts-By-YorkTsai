
知识点回顾
1. 数据结构
@面向对象的数据结构一般设计思路：
基本数据成员（数据属性/成员/域）
数据存储：
线性结构（数组、链表、栈、队列）
树状结构（二叉树、堆）
无序结构（集合、哈希表）
数据操作/函数/方法（增、删、查、改）
面向对象术语对：属性/操作（theory）、成员/函数（C++）、域/方法（Java）
@数据结构分类
“非关联结构” 
线性结构  数组  栈 队列
树状结构 二叉树 B树 堆 并查集Trie树 
网状结构  图
“无序结构”   集合 哈希表

关联结构   键值对 key-value pair
            映射  Map  HashMap/ TreeMap 
               字典？
红黑树专题
5大性质：
左旋、右旋
插入
删除
与AVL树比较


应用：
栈   平衡符号[()]、后缀表达式（逆波兰表达式）、中缀到后缀的转换、方法调用
队列 排队论（queuing theory）

堆 堆数据结构优先权队列、选择算法(最值)、prim 最小生成树、dijkstra、排序算法中有重要应用。
Java对heap的实现是PriorityQueue类，阅读其源码。
创建堆的时间复杂度为O(N)，《数据结构与算法分析——Java语言描述》定理6.1
堆的上滤（precolate up）上滤d层，若交换，赋值次数3d，若“移位”，赋值次数d+1
优先权队列如何实现？插入元素，末尾，自底向上调整；删除元素，交换首尾元素，自顶向下调整。

树、森林定义是什么？如何存储表示？
判断一个图是否一棵树
无重边、无环、仅根节点入度为0、非森林
树的典型应用就是文件系统

二叉树、AVL树、B树、B+树、红黑树如何实现？二叉查找树的用途？（删除操作比较复杂）二叉搜索树（Binary Search Tree）或二叉排序树（Binary Sorted Tree）
线索二叉树？Huffman树？它们的用途？
已知二叉树的先序遍历，求其可能的中序遍历和可能的后序遍历。

二叉查找树 删除节点 2个思路：用左子树的最大节点或者右子树的最小节点代替待删除节点。一般使用后者，因为右子树中的最小节点不可能有左儿子，更容易处理。
二叉查找树的所有节点的期望深度为O(logN)。（等概率，递归分析）

平衡树 AVL树的高度与最少节点数之间的递推关系，与斐波那契数列密切相关

并查集
应用：求无向图的连通分量个数、最近公共祖先 (Least Common Ancestor , Robert Tarjan) (POJ 1330)、带限制的作业排序、实现Kruskal算法求最小生成树等。http://dongxicheng.org/structure/union-find-set/

哈希 任意长度的输入 → 固定长度的输出
任意长度的消息→固定长度的消息摘要
关键字k→ f(k)地址/存储位置
复习HashMap:
key＞key.hashCode＞hash()
＞indexFor(hash, table.length)
key映射到HashMap的内部数组的下标 ，每个数组元素是一个链表节点，相同关键字保存在同一个桶中。拉链法解决散列表冲突。

散列函数的设计
horner法则 进制转换
解决冲突
再散列、可扩散列（实际）
实用散列技术
开放散列：分离链接+再散列
封闭散列：开放地址（平方探测、双散列）+再散列
再散列把程序员从对表大小的担心中解放出来。
再散列的时机
散列表 编译器（符号表）、节点有实名而非数字的图论问题、游戏编制（变换表）、在线拼写检查。第五章 散列 5.13 散列模式串 5.18 拼写检查
哈希就是将一个记录的键值映射到其存储位置的过程。
哈希的“No”：键值相同的多个记录，范围查找，最值查找。
哈希的“Yes”：精确查找，内存或磁盘，数据库（哈希，B树）。

@如何判断图的连通性 并查集 深度优先搜索
@三数中值分割法 排序 选择
@希尔排序，Hibbard增量序列，Sedgewick增量序列
最坏情形时间复杂度
堆垒数论（additive number theory）
@二叉查找树可以迅速找到一定范围内的所有项？
中缀表达式 栈 二叉树
懒惰删除策略
@食物链
数据如何存储并高效检索
@离散数学 关系 向量 并查集
@赢者树与堆的性能比较
赢者树创建复杂度O(k)，建堆O(n)
赢者树不需要节点交换，比堆的性能要好
赢者树能够求第k个最值，堆却不能。
赢者树这块，你还是不熟练
输出1b个数据的前k-th数据
Java有已经实现的赢者树吗？
